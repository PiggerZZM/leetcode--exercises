# 687. 最长同值路径

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

注意：两个节点之间的路径长度由它们之间的边数表示。

## 解法1——递归(PiggerZZM 2020-9-23)

### 思路分析

**同值路径**
首先定义`x`结点的"最深路径"为：从`x`结点起始且只允许向下走的同值路径（题目定义的同值路径允许向上走）。其长度记为`deepestPath[x]`。

每一条"同值路径"可以看作是从根节点向左右延伸得到的。如果把以`root`为根节点的"同值路径"长度记为`longestUnivaluePath[root]`，那么当左子节点`root.left.val`和右子节点`root.right.val`都和`root.val`相等时，可以得到一条关系式：

`longestUnivaluePath[root] = deepestPath[root.left] + deepestPath[root.right] + 2`

根节点的值只和一个子节点的值相等、以及不和子节点的值相等的情况也能相应写出关系式。

根据这个关系式可知，需要先计算出每个结点的"最深路径"长度，才能计算出以每个结点的"同值路径"长度。

**最深路径**

左子节点和右子节点的值都和根节点的值相同情况下，最深路径长度的递推式为：

`deepestPath[x] = max(deepestPath[x.left] + 1, deepestPath[x.right] + 1)`

只和一个根节点的值相同时也能写出对应的递推式。

根据递推式很容易写出一个递归函数来计算最深路径长度。

**算法的框架**
1. 用一个递归函数`longestUnivaluePath(root)`遍历二叉树，对每个节点`x`准备计算以`x`为根的同值路径长度
2. 计算同值路径长度时，需要调用另一个递归函数`deepestPath(root.left)`和`deepestPath(root.right)`来计算左右子节点的最深路径长度
3. 根据根节点和子节点的值是否相等，来计算出以该节点为根的同值路径长度.

沿用这个思路就可以得到v1.0版本的算法。

**算法优化**
不难发现上述算法多次遍历二叉树，每计算一次同值路径长度，就去遍历了左右子树各一次来计算最深路径长度，遍历二叉树的次数非常多。可以通过复杂的算法分析得到时间复杂度是O(nlogn)的。

实际上，在计算`longestUnivaluePath(root's father)`时，需要计算`deepestPath[root]`，于是就需要计算`deepestPath[root.left]`和`deepestPath[root.right]`。
而到了计算`longestUnivaluePath(root)`的时候，又要使用`deepestPath[root.left]`和`deepestPath[root.right]`，这就导致了重复计算，这也是此算法多次遍历二叉树的问题所在。

比较容易想到的优化方法是开一个备忘录，记录每一个`deepestPath[x]`，下次再用的时候如果计算过了就直接取来用。如果是数组实现的二叉树，直接开一个数组作为备忘录即可，如果是链表实现的二叉树，则需要在结点多增加一个域来记录。这种优化方法能够达到时间复杂度为O(n)，但多用了O(n)的额外空间。

更好的优化方法是把计算"最深路径长度"和"同值路径长度"结合到同一个递归函数下。计算出左右子节点的"最深路径长度"时，其实已经可以得到以该结点为根的"同值路径长度"。这种方法时间复杂度是O(n)的，除了递归的空间开销外，不需要任何其他额外的空间开销。